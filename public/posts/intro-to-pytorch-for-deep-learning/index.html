<!DOCTYPE html>
<html>
<head>
	<link rel="icon" type="image/jpg" href="https://image.freepik.com/free-vector/big-data-center-server-room-rack-engineering-process-teamwork-computer-technology-cloud-storage_39422-1032.jpg"/>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Intro to PyTorch for Deep Learning - Deploy Data Science</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta itemprop="name" content="Intro to PyTorch for Deep Learning">
<meta itemprop="description" content="Pytorch is an open source machine learning framework that accelerates the path from research prototyping to production deployment."><meta itemprop="datePublished" content="2021-05-27T11:39:56+00:00" />
<meta itemprop="dateModified" content="2021-05-27T11:39:56+00:00" />
<meta itemprop="wordCount" content="546">
<meta itemprop="keywords" content="Misc,Pytorch,Deep Learning," /><meta property="og:title" content="Intro to PyTorch for Deep Learning" />
<meta property="og:description" content="Pytorch is an open source machine learning framework that accelerates the path from research prototyping to production deployment." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.deploydatascience.com/posts/intro-to-pytorch-for-deep-learning/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-27T11:39:56+00:00" />
<meta property="article:modified_time" content="2021-05-27T11:39:56+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Intro to PyTorch for Deep Learning"/>
<meta name="twitter:description" content="Pytorch is an open source machine learning framework that accelerates the path from research prototyping to production deployment."/>
<link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" type="text/css" media="screen" href="https://www.deploydatascience.com/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://www.deploydatascience.com/css/main.css" />
		<link rel="stylesheet" type="text/css" href="https://www.deploydatascience.com/css/custom.css" />
	

        <link id="dark-scheme" rel="stylesheet" type="text/css" href="https://www.deploydatascience.com/css/dark.css" />
                <link id="dark-scheme" rel="stylesheet" type="text/css" href="https://www.deploydatascience.com/css/custom-dark.css" />

	<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
		<script src="https://www.deploydatascience.com/js/main.js"></script><script src="https://www.deploydatascience.com/js/custom.js"></script><script src="https://www.deploydatascience.com/js/custom1.js"></script>
</head>

<body>
	<div class="container wrapper">
		<div class="header">
	
		<div class="avatar">
			<a href="https://www.deploydatascience.com/">
				<img src="https://image.freepik.com/free-vector/big-data-center-server-room-rack-engineering-process-teamwork-computer-technology-cloud-storage_39422-1032.jpg" alt="Deploy Data Science" />
			</a>
		</div>
	
	<h1 class="site-title"><a href="https://www.deploydatascience.com/">Deploy Data Science</a></h1>
	<div class="site-description"><p>All things Data Science and ML Ops</p><nav class="nav social">
			<ul class="flat"><li><a href="https://github.com/harshalchaudhari35" title="Github"><i data-feather="github"></i></a></li><li><a href="/index.xml" title="RSS"><i data-feather="rss"></i></a></li><li><a href="#" class="scheme-toggle" id="scheme-toggle"></a></li></ul>
		</nav>
	</div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">Home</a>
			</li>
			
			<li>
				<a href="/posts">All posts</a>
			</li>
			
			<li>
				<a href="/about">About</a>
			</li>
			
			<li>
				<a href="/tags">Tags</a>
			</li>
			
			<li>
				<a href="/resources">Resources</a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post">
			<div class="post-header">
				
					<div class="meta">
						<div class="date">
							<span class="day">27</span>
							<span class="rest">May 2021</span>
						</div>
					</div>
				
				<div class="matter">
					<h1 class="title">Intro to PyTorch for Deep Learning</h1>
				</div>
			</div>
					
			<div class="markdown">
				<h2 id="pytorch">PyTorch</h2>
<p>Pytorch is an open source machine learning framework that accelerates the path from research prototyping to production deployment.</p>
<h2 id="regression-problem-example">Regression Problem Example</h2>
<h3 id="boston-housing-dataset">Boston Housing Dataset</h3>
<p>I have used the Boston housing dataset as it is one of the basic and beginner friendly dataset on <a href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques">Kaggle</a></p>
<h3 id="python-implementation">Python Implementation</h3>
<p>The implementation creates a simple neural network using pytorch and compares with a baseline linear regression model.</p>
<h4 id="learnings">Learnings</h4>
<p>Some key lessons learnt are to start with simple datasets and compare with baseline model to see the difference of using a non linear type model.
Data has to be preprocessed into tensors and chunked into batches and then passed to training.</p>
<h4 id="caveats-and-gotchas">Caveats and Gotchas</h4>
<p>Loss Function in pytorch requires to have 2 dimensional tensor for the Y (independent) variable. E.g., for tensor of size 100 the tensor shape should be
(100, 1)</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#00f">import</span> imageio
</span></span><span style="display:flex;"><span><span style="color:#00f">import</span> matplotlib.pyplot <span style="color:#00f">as</span> plt
</span></span><span style="display:flex;"><span><span style="color:#00f">import</span> numpy <span style="color:#00f">as</span> np
</span></span><span style="display:flex;"><span><span style="color:#00f">import</span> pandas <span style="color:#00f">as</span> pd
</span></span><span style="display:flex;"><span><span style="color:#00f">import</span> torch
</span></span><span style="display:flex;"><span><span style="color:#00f">import</span> torch.nn.functional <span style="color:#00f">as</span> F
</span></span><span style="display:flex;"><span><span style="color:#00f">import</span> torch.utils.data <span style="color:#00f">as</span> Data
</span></span><span style="display:flex;"><span><span style="color:#00f">from</span> torch <span style="color:#00f">import</span> tensor
</span></span><span style="display:flex;"><span><span style="color:#00f">from</span> torch.autograd <span style="color:#00f">import</span> Variable
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">from</span> sklearn.metrics <span style="color:#00f">import</span> mean_squared_error
</span></span><span style="display:flex;"><span><span style="color:#00f">from</span> tqdm <span style="color:#00f">import</span> tqdm
</span></span><span style="display:flex;"><span><span style="color:#00f">from</span> sklearn.preprocessing <span style="color:#00f">import</span> MinMaxScaler
</span></span><span style="display:flex;"><span>torch.manual_seed(1)    <span style="color:#008000"># reproducible</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>datadir = <span style="color:#a31515">&#39;./data/&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># get data from kaggle</span>
</span></span><span style="display:flex;"><span>df = pd.read_csv(<span style="color:#a31515">f</span><span style="color:#a31515">&#39;</span><span style="color:#a31515">{</span>datadir<span style="color:#a31515">}</span><span style="color:#a31515">/boston_train.csv&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>y = df[<span style="color:#a31515">&#39;medv&#39;</span>].to_numpy()
</span></span><span style="display:flex;"><span>x = df[[<span style="color:#a31515">&#39;crim&#39;</span>, <span style="color:#a31515">&#39;zn&#39;</span>, <span style="color:#a31515">&#39;indus&#39;</span>, <span style="color:#a31515">&#39;chas&#39;</span>, <span style="color:#a31515">&#39;nox&#39;</span>, <span style="color:#a31515">&#39;age&#39;</span>, <span style="color:#a31515">&#39;dis&#39;</span>, <span style="color:#a31515">&#39;rad&#39;</span>, <span style="color:#a31515">&#39;tax&#39;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a31515">&#39;ptratio&#39;</span>, <span style="color:#a31515">&#39;black&#39;</span>, <span style="color:#a31515">&#39;rm&#39;</span>, <span style="color:#a31515">&#39;lstat&#39;</span>]].to_numpy()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># scaling may be enabled not necessary though</span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># scaler = MinMaxScaler()</span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># x = scaler.fit_transform(x.astype(np.float32))</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x, y = tensor(x.astype(np.float32)), tensor(y.astype(np.float32))
</span></span><span style="display:flex;"><span><span style="color:#008000"># torch can only train on Variable, so convert them to Variable</span>
</span></span><span style="display:flex;"><span>x, y = Variable(x), Variable(y)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># another way to define a network</span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Linear layers do a linear tranformation i.e matrix multiplication</span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># with a constant (bias)</span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># LeakyRelu is an activativation which does non linear transformation</span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Input here 13 is number of features in data</span>
</span></span><span style="display:flex;"><span>net = torch.nn.Sequential(
</span></span><span style="display:flex;"><span>    torch.nn.Linear(13, 200),
</span></span><span style="display:flex;"><span>    torch.nn.LeakyReLU(),
</span></span><span style="display:flex;"><span>    torch.nn.Linear(200, 100),
</span></span><span style="display:flex;"><span>    torch.nn.LeakyReLU(),
</span></span><span style="display:flex;"><span>    torch.nn.Linear(100, 1),
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LR = 0.001
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>optimizer = torch.optim.Adam(net.parameters(), lr=LR)
</span></span><span style="display:flex;"><span><span style="color:#008000"># this is for regression mean squared loss</span>
</span></span><span style="display:flex;"><span>loss_func = torch.nn.MSELoss(reduce=<span style="color:#a31515">&#39;mean&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>BATCH_SIZE = 50
</span></span><span style="display:flex;"><span>EPOCH = 300
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>torch_dataset = Data.TensorDataset(x, y)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loader = Data.DataLoader(
</span></span><span style="display:flex;"><span>    dataset=torch_dataset, 
</span></span><span style="display:flex;"><span>    batch_size=BATCH_SIZE, 
</span></span><span style="display:flex;"><span>    shuffle=<span style="color:#00f">True</span>, num_workers=4,)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">def</span> get_mse(model):
</span></span><span style="display:flex;"><span>    <span style="color:#a31515">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">    Return the accuracy of the model on the input data and actual ground truth.
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    prediction = net(x)     <span style="color:#008000"># input x and predict based on x</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> mean_squared_error(y.data.numpy(),  prediction.data.numpy())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>epoch_losses = []
</span></span><span style="display:flex;"><span>training_accuracy = []
</span></span><span style="display:flex;"><span><span style="color:#008000"># start training</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">for</span> epoch <span style="color:#00f">in</span> range(EPOCH):
</span></span><span style="display:flex;"><span>    losses = []
</span></span><span style="display:flex;"><span>    <span style="color:#008000"># for each training step</span>
</span></span><span style="display:flex;"><span>    <span style="color:#008000"># steps are equal to total rows / batch size</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">for</span> step, (batch_x, batch_y) <span style="color:#00f">in</span> enumerate(loader): 
</span></span><span style="display:flex;"><span>        b_x = Variable(batch_x)
</span></span><span style="display:flex;"><span>        b_y = Variable(batch_y)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>        prediction = net(b_x)     <span style="color:#008000"># input x and predict based on x</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000"># must be (1. nn output, 2. target)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000"># the target must be 2 dimensional array otherwise model</span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000"># predicts same values</span>
</span></span><span style="display:flex;"><span>        loss = loss_func(prediction, torch.unsqueeze(b_y, dim=1))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        optimizer.zero_grad()   <span style="color:#008000"># clear gradients for next train</span>
</span></span><span style="display:flex;"><span>        loss.backward()         <span style="color:#008000"># backpropagation, compute gradients</span>
</span></span><span style="display:flex;"><span>        optimizer.step()        <span style="color:#008000"># apply gradients</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000"># save the current training information</span>
</span></span><span style="display:flex;"><span>        losses.append(float(loss))
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    epoch_losses.append(sum(losses)/step)
</span></span><span style="display:flex;"><span>    training_accuracy.append(get_mse(net))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    print(
</span></span><span style="display:flex;"><span>        <span style="color:#a31515">f</span><span style="color:#a31515">&#34;Epoch #</span><span style="color:#a31515">{</span>epoch+1<span style="color:#a31515">}</span><span style="color:#a31515">\t</span><span style="color:#a31515">Loss: </span><span style="color:#a31515">{</span>epoch_losses[-1]<span style="color:#a31515">:</span><span style="color:#a31515">.3f</span><span style="color:#a31515">}</span><span style="color:#a31515">\t</span><span style="color:#a31515"> MSE: </span><span style="color:#a31515">{</span>training_accuracy[-1]<span style="color:#a31515">}</span><span style="color:#a31515">&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># plotting</span>
</span></span><span style="display:flex;"><span>iters = [i <span style="color:#00f">for</span> i <span style="color:#00f">in</span> range(EPOCH)]
</span></span><span style="display:flex;"><span>plt.plot(iters, epoch_losses)
</span></span><span style="display:flex;"><span>plt.title(<span style="color:#a31515">f</span><span style="color:#a31515">&#34;Training Curve (batch_size=</span><span style="color:#a31515">{</span>BATCH_SIZE<span style="color:#a31515">}</span><span style="color:#a31515">, lr=</span><span style="color:#a31515">{</span>LR<span style="color:#a31515">}</span><span style="color:#a31515">)&#34;</span>)
</span></span><span style="display:flex;"><span>plt.xlabel(<span style="color:#a31515">&#34;Iterations&#34;</span>)
</span></span><span style="display:flex;"><span>plt.ylabel(<span style="color:#a31515">&#34;Loss&#34;</span>)
</span></span><span style="display:flex;"><span>plt.show()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt.plot(iters, training_accuracy)
</span></span><span style="display:flex;"><span>plt.title(<span style="color:#a31515">f</span><span style="color:#a31515">&#34;Training Error (batch_size=</span><span style="color:#a31515">{</span>BATCH_SIZE<span style="color:#a31515">}</span><span style="color:#a31515">, lr=</span><span style="color:#a31515">{</span>LR<span style="color:#a31515">}</span><span style="color:#a31515">)&#34;</span>)
</span></span><span style="display:flex;"><span>plt.xlabel(<span style="color:#a31515">&#34;Iterations&#34;</span>)
</span></span><span style="display:flex;"><span>plt.ylabel(<span style="color:#a31515">&#34;Training Accuracy&#34;</span>)
</span></span><span style="display:flex;"><span>plt.show()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>prediction = net(x)     <span style="color:#008000"># input x and predict based on x</span>
</span></span><span style="display:flex;"><span>mean_squared_error(y.data.numpy(),  prediction.data.numpy())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Compare with Linear regression baseline</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">from</span> sklearn.linear_model <span style="color:#00f">import</span> LinearRegression
</span></span><span style="display:flex;"><span>lm = LinearRegression()
</span></span><span style="display:flex;"><span>lm.fit(x, y)
</span></span><span style="display:flex;"><span>prediction = lm.predict(x)
</span></span><span style="display:flex;"><span>mean_squared_error(y,  prediction)
</span></span></code></pre></div>
			</div>

			<div class="tags">
				
					
						<ul class="flat">
							
							<li><a href="/tags/misc">Misc</a></li>
							
							<li><a href="/tags/pytorch">Pytorch</a></li>
							
							<li><a href="/tags/deep-learning">Deep Learning</a></li>
							
						</ul>
					
				
			</div></div>
	</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div>2023  © Copyright notice |  <a href="https://github.com/knadh/hugo-ink">Ink</a> theme on <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div>

<script>feather.replace()</script>
</body>
</html>
